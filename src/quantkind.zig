const Dimensions = @import("dimensions.zig").Dimensions;
const VALID_MULTS = @import("valid_mults.zig").VALID_MULTS;
const SIOrders = @import("siorders.zig").SIOrders;
const Q = @import("quant.zig").Q;

pub const QuantityKind = enum {
    AbsorbedDoseRate,
    Acceleration,
    Action,
    AmountOfSubstance,
    AngularAcceleration,
    AngularMomemtum,
    Area,
    AreaDensity,
    Capacitance,
    CatalyticActivityConcentration,
    ChemicalPotential,
    Compressibility,
    VolumeDensity,
    DoseEquivalent,
    Density,
    DynamicViscosity,
    ElectricCharge,
    ElectricChargeDensity,
    ElectricField,
    ElectricalConductance,
    ElectricalConductivity,
    ElectricCurrent,
    ElectricPotential,
    ElectricalResistance,
    ElectricalResistivity,
    Energy,
    EnergyDensity,
    EnergyPerMass,
    Entropy,
    Frequency,
    Force,
    HalfLife,
    // todo: should I include heat?
    Heat,
    HeatCapacity,
    HeatFluxDensity,
    Illuminance,
    Impedance,
    Impulse,
    Inductance,
    Irradiance,
    Intensity,
    // todo: should I add kinectic energy?
    KineticEnergy,
    LatentHeat,
    Length,
    LinearDensity,
    LuminousFlux,
    LuminousIntensity,
    MagneticFlux,
    Mass,
    MagneticField,
    // todo: should I keep mean lifetime?
    // MeanLifetime,
    MolarConcentration,
    MolarEnergy,
    MolarEntropy,
    MolarHeatCapacity,
    MomentOfInertia,
    Momemtum,
    NumberOfCycles,
    OpticalPower,
    Permeability,
    Permittivity,
    // todo: should I add potential energy?
    // PotentialEnergy,
    Power,
    Pressure,
    RadioActivity,
    RadiationDose,
    Radiance,
    RadiantIntensity,
    ReactionRate,
    Reluctance,
    SolidAngle,
    SpecificEnergy,
    SpecificHeatCapacity,
    SpecificVolume,
    Speed,
    Spin,
    Stress,
    Strain,
    SurfaceTension,
    Temperature,
    TemperatureDiff,
    ThermalConductance,
    ThermalConductivity,
    ThermalResistance,
    ThermalResistivity,
    Time,
    Velocity,
    Viscosity,
    Volume,
    VolumetricFlowRate,
    Wavelength,
    Wavenumber,
    // todo: should I have work?
    Work,
    YoungsModulous,
    SpringConstant,

    UNKNOWN,

    pub fn to_dimensions(self: QuantityKind) Dimensions {
        var d = Dimensions.zeros();
        return switch (self) {
            .AbsorbedDoseRate => d.setTime(-3).setLength(2),
            .Action => d.setTime(-1).setLength(2).setMass(1),
            .AmountOfSubstance => d.setAmountOfSubstance(1),
            .AngularAcceleration => d.setTime(-2),
            .Area => d.setLength(2),
            .AreaDensity => d.setLength(-2).setMass(1),
            .Capacitance => d.setTime(4).setLength(-2).setMass(-1).setElectricCurrent(2),
            .CatalyticActivityConcentration => d.setTime(-1).setLength(-3).setAmountOfSubstance(1),
            .ChemicalPotential => d.setTime(-2).setLength(2).setMass(1).setAmountOfSubstance(-1),
            .VolumeDensity => d.setLength(-3).setMass(1),
            .DoseEquivalent => d.setTime(-2).setLength(2),
            .ElectricCharge => d.setTime(1).setElectricCurrent(1),
            .ElectricChargeDensity => d.setTime(1).setLength(-3).setElectricCurrent(1),
            .ElectricalConductance => d.setTime(3).setLength(-2).setMass(-1).setElectricCurrent(2),
            .ElectricalConductivity => d.setTime(3).setLength(-3).setMass(-1).setElectricCurrent(2),
            .ElectricCurrent => d.setElectricCurrent(1),
            .ElectricPotential => d.setTime(-3).setLength(2).setMass(1).setElectricCurrent(-1),
            .ElectricalResistance => d.setTime(-3).setLength(2).setMass(1).setElectricCurrent(-2),
            .ElectricalResistivity => d.setTime(-3).setLength(3).setMass(1).setElectricCurrent(-2),
            .Energy => d.setTime(-2).setLength(2).setMass(1),
            .EnergyDensity => d.setTime(-2).setLength(-1).setMass(1),
            .Entropy => d.setTime(-2).setLength(2).setMass(1).setAbsoluteTemperature(-1),
            .Frequency => d.setTime(-1),
            .HalfLife => d.setTime(1),
            .Heat => d.setTime(-2).setLength(2).setMass(1),
            .HeatCapacity => d.setTime(-2).setLength(2).setMass(1).setAbsoluteTemperature(-1),
            .HeatFluxDensity => d.setTime(-3).setMass(1),
            .Illuminance => d.setLength(-2).setLuminousIntensity(1),
            .Impedance => d.setTime(-3).setLength(2).setMass(1).setElectricCurrent(-2),
            .Inductance => d.setTime(-2).setLength(2).setMass(1).setElectricCurrent(-2),
            .Irradiance => d.setTime(-3).setMass(1),
            .Intensity => d.setTime(-3).setMass(1),
            .KineticEnergy => d.setTime(-2).setLength(2).setMass(1),
            .Length => d.setLength(1),
            .LinearDensity => d.setLength(-1).setMass(1),
            .LuminousFlux => d.setLuminousIntensity(1),
            .LuminousIntensity => d.setLuminousIntensity(1),
            .MagneticFlux => d.setTime(-2).setLength(2).setMass(1).setElectricCurrent(-1),
            .Mass => d.setMass(1),
            .MeanLifetime => d.setTime(1),
            .MolarConcentration => d.setLength(-3).setAmountOfSubstance(1),
            .MolarEnergy => d.setTime(-2).setLength(2).setMass(1).setAmountOfSubstance(-1),
            .MolarEntropy => d.setTime(-2).setLength(2).setMass(1).setAbsoluteTemperature(-1).setAmountOfSubstance(-1),
            .MolarHeatCapacity => d.setTime(-2).setLength(2).setMass(1).setAbsoluteTemperature(-1).setAmountOfSubstance(-1),
            .MomentOfInertia => d.setLength(2).setMass(1),
            .OpticalPower => d.setLength(-1),
            .Permeability => d.setTime(-2).setLength(1).setMass(1).setElectricCurrent(-2),
            .Permittivity => d.setTime(4).setLength(-3).setMass(-1).setElectricCurrent(2),
            .PotentialEnergy => d.setTime(-2).setLength(2).setMass(1),
            .Power => d.setTime(-3).setLength(2).setMass(1),
            .Pressure => d.setTime(-2).setLength(-1).setMass(1),
            .RadioActivity => d.setTime(-1),
            .RadiationDose => d.setTime(-2).setLength(2),
            .Radiance => d.setTime(-3).setMass(1),
            .RadiantIntensity => d.setTime(-3).setLength(2).setMass(1),
            .ReactionRate => d.setTime(-1).setLength(-3).setAmountOfSubstance(1),
            .Reluctance => d.setTime(2).setLength(-2).setMass(-1).setElectricCurrent(2),
            .SpecificEnergy => d.setTime(-2).setLength(2),
            .SpecificHeatCapacity => d.setTime(-2).setLength(2).setAbsoluteTemperature(-1),
            .SpecificVolume => d.setLength(3).setMass(-1),
            .Speed => d.setTime(-1).setLength(1),
            .Spin => d.setTime(-1).setLength(2).setMass(1),
            .Stress => d.setTime(-2).setLength(-1).setMass(1),
            .SurfaceTension => d.setTime(-2).setMass(1),
            .Time => d.setTime(1),
            .Temperature => d.setAbsoluteTemperature(1),
            .ThermalConductance => d.setTime(-3).setLength(2).setMass(1).setAbsoluteTemperature(-1),
            .ThermalConductivity => d.setTime(-3).setLength(1).setMass(1).setAbsoluteTemperature(-1),
            .ThermalResistance => d.setTime(3).setLength(-2).setMass(-1).setAbsoluteTemperature(1),
            .ThermalResistivity => d.setTime(3).setLength(-1).setMass(-1).setAbsoluteTemperature(1),
            .Viscosity => d.setTime(-1).setLength(-1).setMass(1),
            .Volume => d.setLength(3),
            .VolumetricFlowRate => d.setTime(-1).setLength(3),
            .Wavelength => d.setLength(1),
            .Wavenumber => d.setLength(-1),
            .Work => d.setTime(-2).setLength(2).setMass(1),
            .YoungsModulus => d.setTime(-2).setLength(-1).setMass(1),
            .SpringConstant => d.setTime(-2).setMass(1),
        };
    }

    pub fn mult_quant_kinds(comptime first_qk: @This(), comptime second_qk: @This()) ?@This() {
        const a = @tagName(first_qk);
        const slice = @field(VALID_MULTS, a);
        for (&slice) |item| {
            if (item[0] == second_qk) {
                return item[1];
            }
        }
        return null;
    }

    pub fn mult_quant_kinds_unchecked(comptime first_qk: @This(), comptime second_qk: @This()) @This() {
        return mult_quant_kinds(first_qk, second_qk) orelse .UNKNOWN;
    }
};
